import java.util.Iterator;

import org.eclipse.ltk.core.refactoring.*;
import org.eclipse.core.resources.IFile;
import org.jastadd.plugin.model.JastAddModel;
import org.eclipse.text.edits.TextEdit;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.ReplaceEdit;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.ltk.core.refactoring.Change;

aspect CreateTextEdit {
	
	// this doesn't really belong here...
	public Stack Program.cloneUndoStack() { return (Stack)undoStack.clone(); }
	
	/* a change accumulator keeps track of changes happening to multiple files;
	 * it creates one TextFileChange for every file affected and adds incoming
	 * ReplaceEdits to them
	 */
	class ChangeAccumulator {
		private String name;
		private CompositeChange changes;
		private Map/*<IFile, TextFileChange>*/ changemap;
		
		public ChangeAccumulator(String name) {
			this.name = name;
			changes = new CompositeChange(name);
			changemap = new HashMap();
		}

		public void addEdit(IFile file, int offset, int length, String contents) {
			TextFileChange tfc;
			// first, determine which TextFileChange the new change should belong to
			if(!changemap.containsKey(file)) {
				// create a new one
				tfc = new TextFileChange(name, file);
				tfc.setEdit(new MultiTextEdit());
				changes.add(tfc);
				changemap.put(file, tfc);
			}
			else {
				tfc = (TextFileChange)changemap.get(file);
			}
			TextEdit new_edit = new ReplaceEdit(offset, length, contents);
			/* when inserting the new edit into tfc, we must be careful to avoid
			 * overlapping edits; our solution here is very simple: walk through
			 * all changes already in tfc, if one of them covers the new change
			 * we don't need to add it, if some of them are covered by the new
			 * change, remove them */
			MultiTextEdit mte = (MultiTextEdit)tfc.getEdit();
			java.util.Set covered = new java.util.HashSet();
			for(int i=0; i<mte.getChildren().length; ++i) {
				TextEdit te = mte.getChildren()[i];
				if(te.covers(new_edit))
					return;
				else if(new_edit.covers(te))
					covered.add(te);
			}
			for(Iterator iter=covered.iterator();iter.hasNext();)
				mte.removeChild((TextEdit)iter.next());
			tfc.addEdit(new_edit);
		}
		
		// creates the TextChanges corresponding to the ASTChanges in some iterator
		// and adds them to the accumulator
		public void addAllEdits(JastAddModel model, Iterator/*<ASTChange>*/ iter) {
			while(iter.hasNext())
				((ASTChange)iter.next()).createTextEdit(model, this);
		}
		
		// directly add a non-TextChange
		public void addChange(Change ch) {
			changes.add(ch);
		}
		
		public Change getChange() {
			return changes;
		}
	}
	
	// every ASTChange should be able to create a text edit that corresponds to
	// its action; however, this method is as yet unimplemented for some changes...
	public void ASTChange.createTextEdit(JastAddModel model, ChangeAccumulator accu) {
		throw new UnsupportedOperationException("ASTNode.createTextEdit()");
	}
	
	public void ReplaceNode.createTextEdit(JastAddModel model, ChangeAccumulator accu) {
		int offset = before.getBeginOffset();
		int length = before.getEndOffset() - offset + 1;
		accu.addEdit(model.getFile(after), offset, length, after.toString());
	}

	public void Rename.createTextEdit(JastAddModel model, ChangeAccumulator accu) {
		entity.createRenameTextEdit(model, accu, old_name, new_name);
	}
	
	// creates a TextEdit corresponding to a rename of this entity
	public void Named.createRenameTextEdit(JastAddModel model, ChangeAccumulator accu, 
			String old_name, String new_name);

	public void VariableDeclaration.createRenameTextEdit(JastAddModel model, 
				ChangeAccumulator accu, String old_name, String new_name) {
		int offset = createOffset(IDstart);
		int offsetEnd = createOffset(IDend);
		int length = offsetEnd - offset + 1;
		accu.addEdit(model.getFile(this), offset, length, new_name);
	}

	public void ParameterDeclaration.createRenameTextEdit(JastAddModel model, 
			ChangeAccumulator accu, String old_name, String new_name) {
		int offset = createOffset(IDstart);
		int offsetEnd = createOffset(IDend);
		int length = offsetEnd - offset + 1;
		accu.addEdit(model.getFile(this), offset, length, new_name);
	}

	public void FieldDeclaration.createRenameTextEdit(JastAddModel model, 
			ChangeAccumulator accu, String old_name, String new_name) {
		int offset = createOffset(IDstart);
		int offsetEnd = createOffset(IDend);
		int length = offsetEnd - offset + 1;
		accu.addEdit(model.getFile(this), offset, length, new_name);
	}

	public void MethodDecl.createRenameTextEdit(JastAddModel model, 
			ChangeAccumulator accu, String old_name, String new_name) {
		int offset = createOffset(IDstart);
		int offsetEnd = createOffset(IDend);
		int length = offsetEnd - offset + 1;
		accu.addEdit(model.getFile(this), offset, length, new_name);
	}

	public void ConstructorDecl.createRenameTextEdit(JastAddModel model, 
			ChangeAccumulator accu, String old_name, String new_name) {
		int offset = createOffset(IDstart);
		int offsetEnd = createOffset(IDend);
		int length = offsetEnd - offset + 1;
		accu.addEdit(model.getFile(this), offset, length, new_name);
	}

	public void TypeDecl.createRenameTextEdit(JastAddModel model, 
			ChangeAccumulator accu, String old_name, String new_name) {
		int offset = createOffset(IDstart);
		int offsetEnd = createOffset(IDend);
		int length = offsetEnd - offset + 1;
		accu.addEdit(model.getFile(this), offset, length, new_name);
	}

	public void CompilationUnit.createRenameTextEdit(JastAddModel model, 
			ChangeAccumulator accu, String old_name, String new_name) {
		IFile file = model.getFile(this);
		accu.addChange(new RenameCompilationUnitChange(file, old_name, new_name));
	}
	
	class RenameCompilationUnitChange extends ResourceChange {
		private final IFile file;
		private final String old_name;
		private final String new_name;
		private final long stamp_to_restore;
		
		public RenameCompilationUnitChange(IFile file, String old_name, String new_name) {
			this(file, old_name, new_name, IResource.NULL_STAMP);
		}
		
		public RenameCompilationUnitChange(IFile file, String old_name, String new_name, long stamp_to_restore) {
			this.file = file;
			this.old_name = old_name;
			this.new_name = new_name;
			this.stamp_to_restore = stamp_to_restore;
		}

		protected final IResource getResource() {
			return ResourcesPlugin.getWorkspace().getRoot().findMember(file.getFullPath());
		}

		public Object getModifiedElement() {
			return JavaCore.create(getResource());
		}

		public String getNewName() {
			return new_name;
		}

		public String getOldName() {
			return old_name;
		}

		public final Change perform(IProgressMonitor pm) throws CoreException {
			try {
				pm.beginTask("Renaming Compilation Unit", 1);
				IResource resource = getResource();
				IPath newPath = createNewPath();
				Change result = createUndoChange(resource.getModificationStamp());
				doRename(new SubProgressMonitor(pm, 1));
				if (stamp_to_restore != IResource.NULL_STAMP) {
					IResource newResource = ResourcesPlugin.getWorkspace().getRoot().findMember(newPath);
					newResource.revertModificationStamp(stamp_to_restore);
				}
				return result;
			} finally {
				pm.done();
			}
		}
		
		protected IPath createNewPath() {
			final IPath path = file.getFullPath();
			if (path.getFileExtension() != null) {
        String extension = path.getFileExtension();
				return path.removeFileExtension().removeLastSegments(1).append(getNewName()).addFileExtension(extension);
			} else
				return path.removeLastSegments(1).append(getNewName());
		}

		protected Change createUndoChange(long stampToRestore) throws JavaModelException {
			//return new RenameCompilationUnitChange(createNewPath(), getNewName(), getOldName(), stampToRestore);
			return null;
		}

		protected void doRename(IProgressMonitor pm) throws CoreException {
			file.move(createNewPath(), false, pm);
		}
		
		public String getName() {
			return "Rename Compilation Unit";
		}

		protected IResource getModifiedResource() {	
			return getResource();
		}
	}

}
