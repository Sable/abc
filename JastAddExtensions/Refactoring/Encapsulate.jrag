/*
 * Encapsulate a field:
 *   1. generate getter and setter methods for the field
 *   2. make the field private
 *   3. adjust all references to the field to use the newly provided methods
 */

aspect Encapsulate {

	public void FieldDeclaration.encapsulate() throws RefactoringException {
		Collection uses = uses();
		AdjustmentTable table = new AdjustmentTable();
		Accessors accessors = new Accessors(this);
		makePrivate();
		RefactoringException rfe;
		for(Iterator i = uses.iterator(); i.hasNext();) {
			VarAccess va = (VarAccess)i.next();
			rfe = va.encapsulate(va, accessors, table);
			if(rfe != null)
				throw rfe;
		}
		programRoot().flushCaches();
		table.adjust();
	}

	inh RefactoringException VarAccess.encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table);
	
	// encapsulate a read access
	public static void ASTNode.encapsulateRead(VarAccess acc, Accessors accessors, AdjustmentTable table) 
			throws RefactoringException {
		MethodDecl getter = accessors.accessor("ASTNode");
		MethodAccess nacc = new MethodAccess(getter.getID(), new List());
		nacc.lockOn(getter);
		acc.replaceWith(nacc);
		table.add(nacc);
	}
	
	// wrapper for ASTNode.encapsulateRead
	eq Program.getChild().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			encapsulateRead(acc, accessors, table);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}
	
	eq AssignExpr.getDest().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor(this.getClass().getSimpleName());
			List args = new List();
			args.add(getSource());
			MethodAccess nacc = new MethodAccess(setter.getID(), args);
			nacc.lockOn(setter);
			acc.replaceWith(nacc);
			replaceWithStripped(getDest());
			table.add(nacc);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}
	
	eq PostfixExpr.getOperand().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor(this.getClass().getSimpleName());
			MethodAccess nacc = new MethodAccess(setter.getID(), new List());
			nacc.lockOn(setter);
			acc.replaceWith(nacc);
			replaceWithStripped(getOperand());
			table.add(nacc);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	eq PreDecExpr.getOperand().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor("PreDecExpr");
			MethodAccess nacc = new MethodAccess(setter.getID(), new List());
			nacc.lockOn(setter);
			acc.replaceWith(nacc);
			replaceWithStripped(getOperand());
			table.add(nacc);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	eq PreIncExpr.getOperand().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			MethodDecl setter = accessors.accessor("PreIncExpr");
			MethodAccess nacc = new MethodAccess(setter.getID(), new List());
			nacc.lockOn(setter);
			acc.replaceWith(nacc);
			replaceWithStripped(getOperand());
			table.add(nacc);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	// inside a qualifier, we have to encapsulate a read access even on the lhs of an assignment
	// (fixes bug uncovered by test case 24)
	eq AbstractDot.getLeft().encapsulate(VarAccess acc, Accessors accessors, AdjustmentTable table) {
		try {
			encapsulateRead(acc, accessors, table);
			return null;
		} catch(RefactoringException rfe) {
			return rfe;
		}
	}

	/* [m.replaceWithStripped(n)] replaces node [m] with node [n], but if
	 * [m]'s parent is an expression statement, then any parentheses surrounding
	 * [n] are stripped off first (otherwise the result would not be valid Java) */
	public void ASTNode.replaceWithStripped(ASTNode n) throws RefactoringException {
		if(getParent() instanceof ExprStmt && n instanceof ParExpr)
			replaceWithStripped(((ParExpr)n).getExpr());
		else
			replaceWith(n);
	}
	
	class Accessors {
		private FieldDeclaration field;
		private Map methods;
		private SimpleSet used;
	}
	
	protected Accessors.Accessors(FieldDeclaration field) throws RefactoringException {
		this.field = field;
		methods = new HashMap();
		used = SimpleSet.emptySet;
		initMethods();
		accessor("ASTNode");
		if(!field.isFinal())
			accessor("AssignSimpleExpr");
	}
		
	private void Accessors.initMethods() {
		methods.put("ASTNode", makeGetter());
		methods.put("AssignSimpleExpr", makeSetter(new AssignSimpleExpr(), "set"));
		methods.put("AssignPlusExpr", makeSetter(new AssignPlusExpr(), "assignPlus"));
		methods.put("AssignMinusExpr", makeSetter(new AssignMinusExpr(), "assignSub"));
		methods.put("AssignAndExpr", makeSetter(new AssignAndExpr(), "assignAnd"));
		methods.put("AssignOrExpr", makeSetter(new AssignOrExpr(), "assignOr"));
		methods.put("AssignXorExpr", makeSetter(new AssignXorExpr(), "assignXor"));
		methods.put("AssignDivExpr", makeSetter(new AssignDivExpr(), "assignDiv"));
		methods.put("AssignModExpr", makeSetter(new AssignModExpr(), "assignMod"));
		methods.put("AssignMulExpr", makeSetter(new AssignMulExpr(), "assignMul"));
		methods.put("AssignLShiftExpr", makeSetter(new AssignLShiftExpr(), "assignLShift"));
		methods.put("AssignRShiftExpr", makeSetter(new AssignRShiftExpr(), "assignRShift"));
		methods.put("AssignURShiftExpr", makeSetter(new AssignURShiftExpr(), "assignURShift"));
		methods.put("PostIncExpr", makeCrement(new PostIncExpr(), "postInc"));
		methods.put("PostDecExpr", makeCrement(new PostDecExpr(), "postDec"));
		methods.put("PreIncExpr", makeCrement(new PreIncExpr(), "preInc"));
		methods.put("PreDecExpr", makeCrement(new PreDecExpr(), "preDec"));
	}

	private MethodDecl Accessors.makeGetter() {
		String getter_name = "get"+ASTNode.capitalize(field.name());
		Block getter_body = new Block();
		getter_body.addStmt(new ReturnStmt(new VarAccess(field.name())));
		return new MethodDecl((Modifiers)field.getModifiers().fullCopy(), 
				(Access)field.getTypeAccess().fullCopy(),
				getter_name, new List(), 
				new List(), new Opt(getter_body));
	}

	private MethodDecl Accessors.makeSetter(AssignExpr assign, String name_prefix) {
		String setter_name = name_prefix+ASTNode.capitalize(field.name());
		Access fieldacc = 
			new ThisAccess("this").qualifiesAccess(new VarAccess(field.name()));
		Access parmacc = new VarAccess(field.name());
		Block setter_body = new Block();
		assign.setDest(fieldacc);
		assign.setSource(parmacc);
		setter_body.addStmt(new ReturnStmt(assign));
		ParameterDeclaration pd = 
			new ParameterDeclaration((Access)field.getTypeAccess().fullCopy(), 
									 field.name());
		List parms = new List();
		parms.add(pd);
		return new MethodDecl((Modifiers)field.getModifiers().fullCopy(), 
				(Access)field.getTypeAccess().fullCopy(),
				setter_name, parms, new List(), 
				new Opt(setter_body));
	}

	private MethodDecl Accessors.makeCrement(Expr expr, String name_prefix) {
		String mname = name_prefix+ASTNode.capitalize(field.name());
		Block getter_body = new Block();
		expr.setChild(new VarAccess(field.name()), 0);
		getter_body.addStmt(new ReturnStmt(expr));
		return new MethodDecl((Modifiers)field.getModifiers().fullCopy(), 
				(Access)field.getTypeAccess().fullCopy(),
				mname, new List(),  
				new List(), new Opt(getter_body));
	}

	public MethodDecl Accessors.accessor(String classname) throws RefactoringException {
		if(used.contains(classname)) {
			return (MethodDecl)methods.get(classname);
		} else {
			used = used.add(classname);
			MethodDecl md = (MethodDecl)methods.get(classname);
			if(md == null)
				throw new RefactoringException("no accessor for "+classname);
			field.hostType().addMethod(md, false, false, false);
			return md;
		}
	}

}