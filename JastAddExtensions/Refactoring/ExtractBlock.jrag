/*
 * The first part of the Extract Method refactoring, Extract Block takes a piece of
 * code (given by its start and end statements) and turns it into a block.
 * 
 * We need to ensure that this is possible (see precondition checks), and possibly
 * move some declarations for variables that are used outside the selection out of
 * the generated block.
 */

aspect ExtractBlock {
	
	public void CompilationUnit.extractBlock(Stmt begin, Stmt end) 
			throws RefactoringException {
		check_block_extraction_preconds(begin, end);
		Block begin_host = begin.hostBlock();
		int begin_idx = begin.indexInHostBlock();
		int end_idx = end.indexInHostBlock();
		begin_host.encapsulate(begin_idx, end_idx);
	}
	
	/*
	 * the preconditions are:
	 *   1. neither begin nor end can be an init or update statement of a for block
	 *   2. begin must dominate end, i.e. every control flow path from the surrounding
	 *      block's entry node to the end node must pass through the begin node
	 *   3. begin and end must be in the same host block
	 *   4. the selection cannot contain case labels
	 */
	private void CompilationUnit.check_block_extraction_preconds(Stmt begin, Stmt end)
			throws RefactoringException {
		if(begin.isInitOrUpdateStmt() || end.isInitOrUpdateStmt())
			throw new RefactoringException("selection cannot start or end at init or update statements");
		if(!begin.dominates(end))
			throw new RefactoringException("begin must dominate end");
		Block begin_host = begin.hostBlock();
		Block end_host = end.hostBlock();
		if(begin_host == null || end_host == null)
			throw new RefactoringException("invalid statement for extraction");
		if(begin_host != end_host)
			throw new RefactoringException("selection straddles block borders");
		int begin_idx = begin.indexInHostBlock();
		int end_idx = end.indexInHostBlock();
		for(int i=begin_idx;i<=end_idx;++i)
			if(begin_host.getStmt(i) instanceof Case)
				throw new RefactoringException("selection cannot contain case labels");
	}
	
	public void Block.encapsulate(int begin, int end) 
			throws RefactoringException {
		Stmt begin_stmt = getStmt(begin);
		Stmt end_stmt = getStmt(end);
		int i; Iterator iter;
		Collection moveOut = localDeclsBetween(begin, end);
		// leave only those decls that are accessed after end
		for(iter=moveOut.iterator();iter.hasNext();) {
			VariableDeclaration vdecl = (VariableDeclaration)iter.next();
			if(!vdecl.accessedAfter(end_stmt))
				iter.remove();
		}
		/*
		 * what we do now:
		 * 1. for every declaration to be moved out, see if it has an initializer
		 *    a) if yes, then insert the declaration (without initializer) at
		 *       position begin++ and replace the original definition by an assignment
		 *    b) if no, then insert the declaration at begin++ and remove original
		 * 2. lock all type accesses
		 * 3. pull statements between begin and end together into a block
		 * 4. unlock all type accesses
		 */
		for(iter=moveOut.iterator();iter.hasNext();) {
			VariableDeclaration vd = (VariableDeclaration)iter.next();
			if(vd.hasInit()) {
				Expr init = vd.getInit();
				Stmt assign = new ExprStmt(new AssignSimpleExpr(
					new VarAccess(vd.getID()), init));
				vd.replaceWith(assign);
				vd = (VariableDeclaration)vd.fullCopy();
				vd.setInitOpt(new Opt());
				insertStmt(begin++, vd);
				++end;
			} else {
				moveStmt(vd, begin++);
			}
		}
		AdjustmentTable table = new AdjustmentTable();
		lockTypeAccesses(table);
		pullTogether(begin, end);
		programRoot().flushCaches();
		table.adjust();
	}
	
	// lock all type accesses in a subtree
	public void ASTNode.lockTypeAccesses(AdjustmentTable table) {
        for(int i = 0; i < getNumChildNoTransform(); i++) {
          ASTNode node = getChildNoTransform(i);
          if(node != null) 
        	  node.lockTypeAccesses(table);
        }
	}
	
	public void TypeAccess.lockTypeAccesses(AdjustmentTable table) {
		table.add(this);
	}
	
}