import java.util.*;

/*
 * The inherited attribute accessVariable(v) computes a VarAccessInfo which
 * describes how to access variable v from the current location in the AST. This
 * VarAccessInfo can in turn be used to construct an actual access.
 * 
 * The implementation of accessVariable is mostly parallel to lookupVariable with
 * the same clauses and the same control flow, but with additional calls to
 * methods "moveInto" and "moveDownTo", which transport a symbolic access from a
 * parent type to a child type resp. an enclosing type to a nested type, adding
 * information about required qualifications in the process. For the implementation
 * of these methods see VarAccessInfo.jrag
 */

aspect AccessVariable {
	
	// cf. lookupVariable(String)
	inh VarAccessInfo TypeDecl.accessVariable(Variable decl);
	inh VarAccessInfo BodyDecl.accessVariable(Variable decl);
	inh VarAccessInfo Stmt.accessVariable(Variable decl);
	inh VarAccessInfo Block.accessVariable(Variable decl);
	inh VarAccessInfo ForStmt.accessVariable(Variable decl);
	inh VarAccessInfo Expr.accessVariable(Variable decl);
	inh VarAccessInfo CatchClause.accessVariable(Variable decl);
	inh VarAccessInfo VariableDeclaration.accessVariable(Variable decl);
	inh VarAccessInfo ParameterDeclaration.accessVariable(Variable decl);

	eq Program.getChild().accessVariable(Variable decl) = null;

	eq TypeDecl.getBodyDecl(int i).accessVariable(Variable decl) {
		VarAccessInfo acc = accessMemberField(decl);
		if(acc != null)	return acc;
		acc = accessVariable(decl);
		if((inStaticContext() || isStatic()) && decl.isInstanceVariable())
			return null;
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	// The scope of a parameter of a method is the entire body of the method
	eq MethodDecl.getBlock().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		// A declaration of a method parameter name shadows any other variable declarations
		if(acc != null) return acc;
		// Delegate to other declarations in scope
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	// A method declaration may only declare one parameter named name
	// This is enforced by a check that the declaration in scope for a declaration is itself
	eq MethodDecl.getParameter().accessVariable(Variable decl) = 
		accessParameterDeclaration(decl);

	eq ConstructorDecl.getBlock().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	eq ConstructorDecl.getConstructorInvocation().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(!decl.isStatic() && decl instanceof FieldDeclaration &&
				((FieldDeclaration)decl).hostType() == hostType())
			return null;
	    if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	eq ConstructorDecl.getParameter().accessVariable(Variable decl) =
		accessParameterDeclaration(decl);

	// The scope of a local variable declaration in a block is the rest of
	// the block in which the declaration appears
	eq Block.getStmt(int index).accessVariable(Variable decl) {
		final int i = index;
		VarAccessInfo acc = accessLocalVariableDeclaration(decl, index);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(new LocalScope() {
				public boolean hasVariable(String name) {
					return localLookupVariable(name, i) != null;
				}
			});
		return null;
	}

	// The scope of the parameter of an exception handler that is declared in a
	// catch clause of a try statement is the entire block associated with the catch
	eq CatchClause.getBlock().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	eq CatchClause.getParameter().accessVariable(Variable decl) = 
		accessParameterDeclaration(decl);

	// The scope of a local variable declared in the ForInit part of the for
	// statement includes all of the following:
	eq ForStmt.getInitStmt().accessVariable(Variable decl) = localAccess(decl);
	eq ForStmt.getCondition().accessVariable(Variable decl) = localAccess(decl);
	eq ForStmt.getUpdateStmt().accessVariable(Variable decl) = localAccess(decl);
	eq ForStmt.getStmt().accessVariable(Variable decl) = localAccess(decl);

	// cf. localLookup(String)
	syn VarAccessInfo ForStmt.localAccess(Variable decl) {
		VarAccessInfo acc = accessLocalVariableDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	// cf. parameterDeclaration(String)
	syn VarAccessInfo MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d == decl)
				return new LocalVarAccessInfo(decl);
		return null;
	}

	syn VarAccessInfo ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i) == decl)
				return new LocalVarAccessInfo(decl);
		return null;
	}

	syn VarAccessInfo CatchClause.accessParameterDeclaration(Variable decl) = 
		getParameter() == decl ? new LocalVarAccessInfo(decl) : null;

	// cf. localVariableDeclaration(String)
	syn VarAccessInfo Block.accessLocalVariableDeclaration(Variable decl, int index) {
		for(int i = 0; i<=index; i++)
			if(getStmt(i) == decl)
				return new LocalVarAccessInfo(decl);
		return null;
	}

	syn VarAccessInfo ForStmt.accessLocalVariableDeclaration(Variable decl) {
		for(int i = 0; i < getNumInitStmt(); i++)
			if(getInitStmt(i) == decl)
				return new LocalVarAccessInfo(decl);
		return null;
	}

	eq MethodAccess.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ConstructorAccess.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq SuperConstructorAccess.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ArrayAccess.getExpr().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ArrayTypeWithSizeAccess.getExpr().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);
	eq ClassInstanceExpr.getArg().accessVariable(Variable decl) = unqualifiedScope().accessVariable(decl);

	eq AbstractDot.getRight().accessVariable(Variable decl) = getLeft().qualifiedAccessVariable(decl);

	eq ParseName.qualifiedAccessVariable(Variable decl) = null;
	eq PackageOrTypeAccess.qualifiedAccessVariable(Variable decl) = null;
	eq AmbiguousAccess.qualifiedAccessVariable(Variable decl) = null;

	// cf. qualifiedLookupVariable(String)
	syn VarAccessInfo Expr.qualifiedAccessVariable(Variable decl) {
		if(type().accessibleFrom(hostType())) {
			VarAccessInfo acc = type().accessMemberField(decl);
			if(acc != null && isAccessibleField(decl)) return acc;
		}
		return null;
	}

	eq PackageAccess.qualifiedAccessVariable(Variable decl) = null;

	eq TypeAccess.qualifiedAccessVariable(Variable decl) {
		if(type().accessibleFrom(hostType())) {
			VarAccessInfo acc = type().accessMemberField(decl);
			if(acc != null && isAccessibleField(decl) && !decl.isInstanceVariable())
				return acc;
		}
		return null;
	}

	// check whether field is accessible when using this Expr as qualifier
	public boolean Expr.isAccessibleField(Variable decl) {
		return decl instanceof FieldDeclaration && 
				mayAccess((FieldDeclaration)decl);
	}

	// cf. memberFields(String)
	syn VarAccessInfo TypeDecl.accessMemberField(Variable decl) = 
		accessField(decl);

	// cf. localFields(String)
	syn VarAccessInfo TypeDecl.accessLocalField(Variable decl) {
    for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
      FieldDeclaration f = (FieldDeclaration)iter.next();
      if(f == decl)
				return new VarAccessInfo(this, this, false, decl);
    }
		return null;
	}

	// cf. fields(String)
	syn VarAccessInfo TypeDecl.accessField(Variable decl) = 
		accessLocalField(decl);
	
	syn boolean Variable.isPrivateField();
	eq FieldDeclaration.isPrivateField() = isPrivate();
	eq VariableDeclaration.isPrivateField() = false;
	eq ParameterDeclaration.isPrivateField() = false;
	
	syn boolean Variable.isAccessibleFrom(TypeDecl td);
	eq FieldDeclaration.isAccessibleFrom(TypeDecl td) = accessibleFrom(td);
	eq VariableDeclaration.isAccessibleFrom(TypeDecl td) = true;
	eq ParameterDeclaration.isAccessibleFrom(TypeDecl td) = true;

	eq ClassDecl.accessField(Variable decl) {
		VarAccessInfo acc = accessLocalField(decl);
		if(acc != null) return acc;
		if(hasSuperclass()) {
			acc = superclass().accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return acc.moveDownTo(this);
		}
		for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}

	eq InterfaceDecl.accessField(Variable decl) {
		VarAccessInfo acc = accessLocalField(decl);
		if(acc != null) return acc;
		for(Iterator iter = superinterfacesIterator(); iter.hasNext(); ) {
			TypeDecl type = (TypeDecl)iter.next();
			acc = type.accessField(decl);
			if(acc != null && !decl.isPrivateField() && decl.isAccessibleFrom(this))
				return acc.moveDownTo(this);
		}
		return null;
	}
		
	public Expr Access.getCompleteQualifier() {
		if(this.isLeftChildOfDot()) {
			return parentDot().getCompleteQualifier();
		} else if(this.isRightChildOfDot()) {
			Expr uncle = (Expr)parentDot().getLeft().fullCopy();
			Expr qual = parentDot().getCompleteQualifier();
			if(qual == null) return uncle;
			return qual.qualifiesAccess((Access)uncle);
		} else {
			return null;
		}
	}

	public Access Access.access(Variable v) {
		VarAccessInfo acc = accessVariable(v);
		if(acc == null) return null;
		if(isQualified())
			return acc.computeQualifiedAccess(unqualifiedScope().getNamingContext(),
			       qualifier().type(), getCompleteQualifier());
		else
			return acc.computeAccess(getNamingContext());
	}
		
}
