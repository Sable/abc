aspect MethodAccessInfo {
	
	class MethodAccessInfo extends AccessInfo<MethodDecl> {
		
		public MethodAccessInfo(TypeDecl source, TypeDecl bend, 
									boolean needsQualifier,	MethodDecl target) {
			super(source, bend, needsQualifier, target);
		}
	}

	public MethodAccessInfo MethodAccessInfo.moveDownTo(TypeDecl td) {
		bend = td;
		if(!td.localMethods(target.name()).isEmpty())
			needsQualifier = true;
		else if(!needsQualifier)
			source = td;
		return this;
	}
		
	public MethodAccessInfo MethodAccessInfo.moveInto(TypeDecl td) {
		if(!td.memberMethods(target.name()).isEmpty())
			needsQualifier = true;
		return this;
	}
		
	public Access MethodAccessInfo.computeAccess(NamingContext ctxt, List args) {
		if(needsQualifier) {
			if(target.isStatic())
				return computeStaticAccess(ctxt, args);
			if(ctxt.isStatic())
				return null;
			if(source == bend) {
				return computeThisAccess(ctxt, args);
			} else if(bend instanceof ClassDecl && 
						source == ((ClassDecl)bend).superclass()) {
				return computeSuperAccess(ctxt, args);
			/*} else if(target.isStatic()) {
				Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
				if(upper == null) return null;
				if(bend == ctxt.enclosingType()) {
					return new ParExpr(new CastExpr(upper, new ThisAccess("this"))).qualifiesAccess(ma);
				} else {
					Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
					if(outer == null) return null;
					return new ParExpr(new CastExpr(upper, outer.qualifiesAccess(new ThisAccess("this")))).
									   qualifiesAccess(ma);
				}*/
			} else {
				return null;
			}
		} else {
			return new MethodAccess(target.name(), args);
		}
	}
	
	public Access MethodAccessInfo.computeStaticAccess(NamingContext ctxt, List args) {
		MethodAccess ma = new MethodAccess(target.name(), args);
		Access source_acc = ctxt.accessType(source, true);
		if(source_acc == null) return null;
		return source_acc.qualifiesAccess(ma);
	}
	
	public Access MethodAccessInfo.computeThisAccess(NamingContext ctxt, List args) {
		MethodAccess ma = new MethodAccess(target.name(), args);
		if(source == ctxt.enclosingType()) {
			return ma;
		} else {
			Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
			if(outer == null) return null;
			return outer.qualifiesAccess(new ThisAccess("this").qualifiesAccess(ma));
		}
	}
	
	public Access MethodAccessInfo.computeSuperAccess(NamingContext ctxt, List args) {
		MethodAccess ma = new MethodAccess(target.name(), args);
		if(bend == ctxt.enclosingType())
			return new SuperAccess("super").qualifiesAccess(ma);
		else {
			Access outer = ctxt.unqualifiedCtxt().accessType(bend, false);
			if(outer == null) return null;
			return outer.qualifiesAccess(new SuperAccess("super").qualifiesAccess(ma));
		}
	}
	
	public Access MethodAccessInfo.computeQualifiedAccess(NamingContext ctxt, TypeDecl qual_type, 
	       	      					      Expr qualifier, List args) {
		MethodAccess ma = new MethodAccess(target.name(), args);
		if(needsQualifier) {
			if(!target.isStatic())
				return null;
			if(ctxt.isStatic())
				if(qualifier.isTypeAccess() && qual_type == source)
					return qualifier.qualifiesAccess(ma);
				else
					return null;
			if(source == bend && source == qual_type)
				return qualifier.qualifiesAccess(ma);
			else if(!qualifier.isTypeAccess()) {
				Access upper = ctxt.accessType(source, false);
				if(upper != null && bend == qual_type)
					return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
			}
			return null;
		} else {
			return qualifier.qualifiesAccess(ma);
		}
	}	
		
}
