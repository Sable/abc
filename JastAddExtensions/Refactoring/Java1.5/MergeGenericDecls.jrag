aspect MergeGenericDecls {
  
	// a coarser form of equality that considers, for example, a method from a generic
	// class and its counterpart from a parametrised instance of the class to be the same
	syn boolean TypeDecl.sameSourceDeclAs(TypeDecl decl) 
		= sourceTypeDecl() == decl.sourceTypeDecl();
	syn boolean MethodDecl.sameSourceDeclAs(MethodDecl decl) 
		= sourceMethodDecl() == decl.sourceMethodDecl();
	syn boolean Variable.sameSourceDeclAs(Variable decl) 
		= sourceVariableDecl() == decl.sourceVariableDecl();

	// we need to refine a bunch of methods to use sameSourceDeclAs() instead of "=="
	refine AccessMethod	public MethodAccessInfo TypeDecl.accessLocalMethod(MethodDecl md) {
		for(Iterator iter = localMethodsIterator(); iter.hasNext(); ) {
			MethodDecl m = (MethodDecl)iter.next();
			if(m.sameSourceDeclAs(md))
				return new MethodAccessInfo(this, this, false, md); 
		}
		return null;
	}

	refine AccessType eq Program.accessType(TypeDecl td) {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			for(int j = 0; j < getCompilationUnit(i).getNumTypeDecl(); j++)
				if(getCompilationUnit(i).getTypeDecl(j).sameSourceDeclAs(td))
					return td.getAccessInfo(true);
		return null;
	}

	refine AccessType eq ClassInstanceExpr.qualifiedAccessType(TypeDecl td) {
		TypeAccessInfo acc = type().accessMemberType(td);
		if(acc != null && typeAccessible(td))
			return acc;
		if(type().sameSourceDeclAs(td))
			return td.getAccessInfo().moveInto(this);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.getConstructorInvocation().accessVariable(Variable decl) {
		VarAccessInfo acc = accessParameterDeclaration(decl);
		if(acc != null) return acc;
		acc = accessVariable(decl);
		if(!decl.isStatic() && decl instanceof FieldDeclaration &&
				((FieldDeclaration)decl).hostType().sameSourceDeclAs(hostType()))
			return null;
	    if(acc != null)
			return acc.moveInto(this);
		return null;
	}

	refine AccessType eq TypeDecl.accessLocalType(TypeDecl td) {
		for(Iterator iter = localTypeDecls(td.name()).iterator(); iter.hasNext(); ) {
			TypeDecl t = (TypeDecl)iter.next();
			if(t.sameSourceDeclAs(td))
				return td.getAccessInfo();
		}
		return null;
	}

	refine AccessType eq CompilationUnit.accessLocallyDefinedType(TypeDecl td) {
		for(TypeDecl td2 : getTypeDecls())
			if(td.sameSourceDeclAs(td2))
				return td.getAccessInfo();
		return null;
	}

	refine AccessType eq SingleTypeImportDecl.accessImportedType(TypeDecl td) {
		if(td.sameSourceDeclAs(getAccess().type()))
			return td.getAccessInfo();
		return null;
	}

	refine AccessVariable eq MethodDecl.accessParameterDeclaration(Variable decl) {
		for(ParameterDeclaration d : getParameters())
			if(d.sameSourceDeclAs(decl))
				return new LocalVarAccessInfo(decl);
		return null;
	}

	refine AccessVariable eq ConstructorDecl.accessParameterDeclaration(Variable decl) {
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).sameSourceDeclAs(decl))
				return new LocalVarAccessInfo(decl);
		return null;
	}

	refine AccessVariable eq TypeDecl.accessLocalField(Variable decl) {
		for(Iterator iter = localFields(decl.name()).iterator(); iter.hasNext(); ) {
			FieldDeclaration f = (FieldDeclaration)iter.next();
			if(f.sameSourceDeclAs(decl))
				return new VarAccessInfo(this, this, false, decl);
		}
		return null;
	}

	refine AdjustAccess public void VarAccess.lock() { target = decl().sourceVariableDecl(); }

	refine AdjustAccess public void VarAccess.unlockSafely() throws RefactoringException {
		Variable v = target;
		unlock();
		if(decl().sourceVariableDecl() == v)
			return;
		Access acc = access(v);
		if(acc == null)
			throw new RefactoringException("variable cannot be accessed");
		plugInNewAccess(acc);
	}
	
	refine AdjustAccess public void TypeAccess.lock() { target = decl().sourceTypeDecl(); }

	refine AdjustAccess public void TypeAccess.unlockSafely() throws RefactoringException {
		TypeDecl td = target;
		unlock();
		if(possiblyObscured() || decl().sourceTypeDecl() != td) {
			Access acc = access(td, nameType() == NameType.AMBIGUOUS_NAME);
			if(acc == null)
				throw new RefactoringException("type cannot be accessed");
			plugInNewAccess(acc);
		}
	}
	
	refine AdjustAccess public void MethodAccess.lock() { target = decl().sourceMethodDecl(); }

	refine AdjustAccess public void MethodAccess.unlockSafely() throws RefactoringException {
		MethodDecl md = target;
		unlock();
		if(decl().sourceMethodDecl() == md)
			return;
		Access acc = access(md, (List<Expr>)getArgs().fullCopy());
		if(acc == null)
			throw new RefactoringException("method cannot be accessed");
		plugInNewAccess(acc);
	}
	
	refine MethodAccessInfo public Access MethodAccessInfo.computeQualifiedAccess(NamingContext ctxt, TypeDecl qual_type, Expr qualifier, List args) {
		MethodAccess ma = new MethodAccess(target.name(), args);
		if(needsQualifier) {
			if(!target.isStatic())
				return null;
			if(ctxt.isStatic())
				if(qualifier.isTypeAccess() && qual_type.sameSourceDeclAs(source))
					return qualifier.qualifiesAccess(ma);
				else
					return null;
			if(source == bend && source.sameSourceDeclAs(ctxt.enclosingType()))
				return qualifier.qualifiesAccess(ma);
			else if(!qualifier.isTypeAccess()) {
				Access upper = ctxt.unqualifiedCtxt().accessType(source, false);
				if(upper != null && bend.sameSourceDeclAs(ctxt.enclosingType()))
					return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(ma);
			}
			return null;
		} else {
			return qualifier.qualifiesAccess(ma);
		}
	}
	
	refine VarAccessInfo public Access VarAccessInfo.computeQualifiedAccess(NamingContext outer, TypeDecl qual_type, Expr qualifier) {
		VarAccess va = new VarAccess(target.name());
		if(needsQualifier) {
			if(source == bend && source.sameSourceDeclAs(qual_type))
				return qualifier.qualifiesAccess(va);
			else if(!qualifier.isTypeAccess()) {
				Access upper = outer.accessType(source, false);
				if(upper != null && bend.sameSourceDeclAs(qual_type))
					return new ParExpr(new CastExpr(upper, qualifier)).qualifiesAccess(va);
			}
			return null;
		} else {
			return qualifier.qualifiesAccess(new VarAccess(target.name()));
		}
	}
}
