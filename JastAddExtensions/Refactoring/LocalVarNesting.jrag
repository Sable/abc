/*
 * When we rename a local variable, it is important to check that the new name does
 * not clash with the name of an already existing local variable. The attribute
 * acceptLocal(id) checks whether a node and its children could be inside the scope
 * of a local variable named id; if not, it _returns_ (not throws!) a refactoring
 * exception; if everything is OK, it returns null
 * 
 * this somewhat weird behaviour is due to the fact that attributes cannot throw
 * exceptions
 */

aspect LocalVarNesting {
	
	interface Initializer {
		Block getBlock();
	}
	
	InstanceInitializer implements Initializer;
	StaticInitializer implements Initializer;
	
	syn RefactoringException BodyDecl.acceptLocal(String name) = null;
	
	eq Callable.acceptLocal(String name) {
		if(!parameterDeclaration(name).isEmpty())
			return new RefactoringException("parameter of the same name exists");
		if(hasBody())
			return getBlock().acceptLocal(name);
		return null;
	}
	
	eq Initializer.acceptLocal(String name) = getBlock().acceptLocal(name);
	
	syn RefactoringException Stmt.acceptLocal(String name) = null;
	
	eq Block.acceptLocal(String name) {
		RefactoringException e;
		for(int i=0;i<getNumStmt();++i) {
			e = getStmt(i).acceptLocal(name);
			if(e != null) return e;
		}
		return null;
	}
	
	eq DoStmt.acceptLocal(String name) = getStmt().acceptLocal(name);
	eq WhileStmt.acceptLocal(String name) = getStmt().acceptLocal(name);
	
	eq SwitchStmt.acceptLocal(String name) = getBlock().acceptLocal(name);
	
	eq ForStmt.acceptLocal(String name) {
		RefactoringException e;
		int i;
		for(i=0;i<getNumInitStmt();++i) {
			e = getInitStmt(i).acceptLocal(name);
			if(e != null) return e;
		}
		// the update statement cannot declare variables, so we can ignore it
        e = this.getStmt().acceptLocal(name);
        return e;
	}
	
	eq IfStmt.acceptLocal(String name) {
		RefactoringException e;
		e = getThen().acceptLocal(name);
		if(e != null) return e;
		if(hasElse())
			e = getElse().acceptLocal(name);
		return e;
	}
	
	eq TryStmt.acceptLocal(String name) {
		RefactoringException e;
		e = getBlock().acceptLocal(name);
		if(e != null) return e;
		for(int i=0;i<getNumCatchClause();++i) {
			CatchClause cc = getCatchClause(i);
			e = cc.getParameter().acceptLocal(name);
			if(e != null) return e;
			e = cc.getBlock().acceptLocal(name);
			if(e != null) return e;
		}
		if(hasFinally())
			e = getFinally().acceptLocal(name);
		return e;
	}
	
	eq VariableDeclaration.acceptLocal(String name) {
		if(name.equals(getID()))
			return new RefactoringException("local variable of same name exists");
		return null;
	}
	
	syn RefactoringException ParameterDeclaration.acceptLocal(String name) {
		if(name.equals(getID()))
			return new RefactoringException("parameter of same name exists");
		return null;
	}
	
}